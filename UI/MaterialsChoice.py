# -*- coding: utf-8 -*-
import json
import pickle

# Form implementation generated from reading ui file 'QtDesignerFiles/MaterialsChoice.ui'
#
# Created by: PyQt5 UI code generator 5.15.5
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets

from dataclasses import dataclass

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


@dataclass
class Syrio:
    name: str
    percentage: float
    density: float
    color: QtCore.Qt.GlobalColor


class DragButton(QPushButton):
    def __init__(self, surio, parent=None):
        super().__init__(parent)

        self.surio = surio

        color = QColor(surio.color)
        self.setStyleSheet(f"background-color: {color.name()};")
        self.setText(f"{self.surio.name} ({self.surio.percentage}%, {self.surio.density} кг/м³)")

    def mouseMoveEvent(self, e):
        if e.buttons() == Qt.LeftButton:
            drag = QDrag(self)
            mime = QMimeData()

            surio_data = json.dumps({
                "name": self.surio.name,
                "percentage": self.surio.percentage,
                "density": self.surio.density,
                "color": QColor(self.surio.color).name(),
            })
            mime.setText(surio_data)

            drag.setMimeData(mime)

            # Создаем pixmap для перетаскивания
            pixmap = QPixmap(self.size())
            self.render(pixmap)
            drag.setPixmap(pixmap)

            drag.exec_(Qt.MoveAction)

class DragDropGroupBox(QGroupBox):
    def __init__(self, parent=None, reactor_height=1.4):
        super().__init__(parent)
        self.reactor_height = reactor_height  # Высота реактора в метрах

        # Виджет для отрисовки реактора
        self.reactorArea = QWidget(self)
        self.reactorArea.setAcceptDrops(True)
        self.reactorArea.setGeometry(10, 0, 291, 450)
        self.reactorArea.setObjectName("reactorArea")
        self.reactorArea.paintEvent = self.paintReactor

        # Объединенный список для слоев и сырья
        self.items_and_layers = []
        self.firstLayer()

    def firstLayer(self):
        self.addLayer(0.0)
        self.addLayer(self.reactor_height)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():  # Проверяем, есть ли текстовые данные
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        event.accept()

    def dropEvent(self, event):
        """Обрабатываем событие падения данных."""
        mime_data = event.mimeData()
        surio = None

        if mime_data.hasText():
            try:
                # Парсим текст как JSON для восстановления объекта Syrio
                surio_data = json.loads(mime_data.text())
                surio = Syrio(
                    name=surio_data["name"],
                    percentage=surio_data["percentage"],
                    density=surio_data["density"],
                    color=QColor(surio_data["color"]),
                )
            except json.JSONDecodeError:
                print("Ошибка при декодировании данных Syrio")

        if surio:
            print(f"Dropped Syrio: {surio}")
            self.addNewItem(surio, event.pos())

        event.acceptProposedAction()

    def addNewItem(self, surio, position, realPos = None):
        """Добавляет сырье как окрашиваемый прямоугольник между слоями на основе позиции перетаскивания."""
        reactor_height_px = self.reactorArea.height()

        # Преобразуем координаты в относительные высоты слоев
        if position != None:
            pos_y = position.y() - 10
            new_layer = self.reactor_height * (1 - pos_y / reactor_height_px)
        else:
            new_layer = realPos

        if self.isSpaceAvailable(new_layer):
            left_layer = None
            right_layer = None

            # Находим два ближайших слоя
            for i in range(len(self.items_and_layers) - 1):
                if self.items_and_layers[i][0] == "layer" and self.items_and_layers[i + 1][0] == "layer":
                    if self.items_and_layers[i][1] < new_layer < self.items_and_layers[i + 1][1]:
                        left_layer = self.items_and_layers[i]
                        right_layer = self.items_and_layers[i + 1]
                        break

            if left_layer and right_layer:
                # Рассчитываем координаты прямоугольника
                left_pos = reactor_height_px - int((left_layer[1] / self.reactor_height) * reactor_height_px)
                right_pos = reactor_height_px - int((right_layer[1] / self.reactor_height) * reactor_height_px)

                # Создаем новый окрашиваемый прямоугольник (QWidget)
                new_item = QWidget(self.reactorArea)
                new_item.setStyleSheet(f"background-color: {surio.color.name()};")
                new_item.setContextMenuPolicy(Qt.CustomContextMenu)
                new_item.customContextMenuRequested.connect(
                    lambda pos, btn=new_item: self.showContextMenu(pos, btn)
                )  # Подключаем контекстное меню

                # Определяем высоту прямоугольника как расстояние между слоями
                item_height = abs(left_pos - right_pos)

                # Определяем координаты прямоугольника (от верхнего слоя до нижнего)
                new_item.setGeometry(0, min(left_pos, right_pos) + 1, self.reactorArea.width(), item_height - 1)

                # Добавляем элемент в общий список
                self.items_and_layers.append(("item", new_layer, new_item, surio))
                self.items_and_layers.sort(key=lambda item: item[1])  # Сортируем по высоте слоев

                self.reactorArea.update()  # Перерисовываем реактор

    def showContextMenu(self, position, item):
        """Показывает контекстное меню при правом клике на элемент (прямоугольник)."""
        menu = QMenu(self)
        delete_action = menu.addAction("Удалить")
        action = menu.exec_(item.mapToGlobal(position))
        if action == delete_action:
            self.removeItem(item)

    def showLayerContextMenu(self, position, layer_widget):
        """Показывает контекстное меню для слоя."""
        menu = QMenu(self)
        delete_action = menu.addAction("Удалить слой")
        action = menu.exec_(layer_widget.mapToGlobal(position))
        if action == delete_action:
            self.removeLayer(layer_widget)

    def removeLayer(self, layer):
        """Удаляет указанный слой."""
        self.items_and_layers = [(type_, position, item, n) for type_, position, item, n in self.items_and_layers if item != layer]
        layer.deleteLater()
        self.reactorArea.update()

    def removeItem(self, item):
        """Удаляет указанный элемент (прямоугольник)."""
        self.items_and_layers = [(type_, position, i, s) for type_, position, i, s in self.items_and_layers if i != item]
        item.deleteLater()
        self.reactorArea.update()

    def addLayer(self, position):
        """Добавляет слой на указанную позицию и автоматически заполняет промежутки сырьем."""
        reactor_height_px = self.reactorArea.height()

        if any(layer[0] == "layer" and layer[1] == position for layer in self.items_and_layers):
            print(f"Layer at position {position} already exists. Skipping addition.")
            return

            # Перевод высоты слоя из метров в пиксели
        y_pos = reactor_height_px - int((position / self.reactor_height) * reactor_height_px)

        # Создаем виджет слоя
        layer_widget = QWidget(self.reactorArea)
        layer_widget.setStyleSheet("background-color: rgb(0, 0, 0); border: 2px solid black;")
        layer_widget.setGeometry(0, y_pos, self.reactorArea.width(), 2)  # Высота слоя 2px
        layer_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        layer_widget.customContextMenuRequested.connect(
            lambda pos, lw=layer_widget: self.showLayerContextMenu(pos, lw)
        )

        # Добавляем слой в общий список
        self.items_and_layers.append(("layer", position, layer_widget, None))
        self.items_and_layers.sort(key=lambda item: item[1])  # Сортируем по высоте

        # Проверяем и добавляем промежуточные элементы
        self.handleIntermediateItems(layer_widget)

        self.reactorArea.update()  # Перерисовываем реактор

    def handleIntermediateItems(self, layer_widget):
        """Проверяет соседние слои и добавляет промежуточные элементы, если необходимо."""
        new_items = []  # Чтобы избежать изменения списка в процессе итерации

        for i, (element_type, position, widget, _) in enumerate(self.items_and_layers):
            if widget == layer_widget and element_type == "layer":

                try:
                    # Проверяем элемент слева
                    if self.items_and_layers[i - 1][0] == "layer":
                        left_layer = self.items_and_layers[i - 1]

                        # Берем следующий элемент для проверки (если есть сырье)
                        if i + 1 < len(self.items_and_layers):
                            right_item = self.items_and_layers[i + 1]  # Следующий элемент
                            if right_item[0] == "item":
                                middle_position = (left_layer[1] + position) / 2
                                new_items.append(
                                    ("item", middle_position, self.addIntermediateItem(right_item[3], middle_position)))

                except IndexError:
                    print(f"Ошибка при обработке левого элемента на позиции {position}")

                try:
                    # Проверяем элемент справа
                    if self.items_and_layers[i + 1][0] == "layer":
                        right_layer = self.items_and_layers[i + 1]

                        # Берем предыдущий элемент для проверки (если есть сырье)
                        if i > 0:
                            left_item = self.items_and_layers[i - 1]  # Предыдущий элемент
                            if left_item[0] == "item":
                                middle_position = (position + right_layer[1]) / 2
                                new_items.append(
                                    ("item", middle_position, self.addIntermediateItem(left_item[3], middle_position)))

                except IndexError:
                    print(f"Ошибка при обработке правого элемента на позиции {position}")

        self.items_and_layers.sort(key=lambda item: item[1])

    def addIntermediateItem(self, source_item, realPos):
        """Создает новое сырье, копируя стиль и свойства из существующего."""
        self.addNewItem(source_item, None, realPos)

    def isSpaceAvailable(self, new_item):
        """Проверяет, есть ли свободное пространство между слоями для добавления сырья."""
        left_layer = None
        right_layer = None

        for i in range(len(self.items_and_layers) - 1):
            if self.items_and_layers[i][0] == "layer" and self.items_and_layers[i + 1][0] == "layer":
                if self.items_and_layers[i][1] < new_item < self.items_and_layers[i + 1][1]:
                    left_layer = self.items_and_layers[i]
                    right_layer = self.items_and_layers[i + 1]
                    break

        # Проверяем, есть ли уже элементы между найденными слоями
        for item in self.items_and_layers:
            if item[0] == "item":
                left_layer_2 = None
                right_layer_2 = None
                for i in range(len(self.items_and_layers) - 1):
                    if self.items_and_layers[i][0] == "layer" and self.items_and_layers[i + 1][0] == "layer":
                        if self.items_and_layers[i][1] < item[1] < self.items_and_layers[i + 1][1]:
                            left_layer_2 = self.items_and_layers[i]
                            right_layer_2 = self.items_and_layers[i + 1]
                            break

                if left_layer == left_layer_2 and right_layer == right_layer_2:
                    return False

        return True

    def paintReactor(self, event):
        """Рисует слои реактора как отдельные виджеты и размещает элементы."""
        reactor_height_px = self.reactorArea.height()

        # Проходим по всем элементам и обновляем их позицию
        for i in range(len(self.items_and_layers)):
            type_, layer_pos, item, _ = self.items_and_layers[i]

            if type_ == 'item':  # Если это элемент (сырье)
                # Находим два ближайших слоя для сырья
                left_layer = self.items_and_layers[i - 1]  # левый слой
                right_layer = self.items_and_layers[i + 1]

                # Рассчитываем координаты для левого и правого слоя
                left_pos = reactor_height_px - int(
                    (left_layer[1] / self.reactor_height) * reactor_height_px)
                right_pos = reactor_height_px - int(
                    (right_layer[1] / self.reactor_height) * reactor_height_px)

                # Обновляем геометрию материала между слоями
                item.setGeometry(0, min(left_pos, right_pos) + 2, self.reactorArea.width(), abs(left_pos - right_pos) - 2)

        # Отображаем все элементы
        for el in self.items_and_layers:
            el[2].show()


class PointsScrollerWidget(QtWidgets.QWidget):
    def setupController(self, Controller):
        self.Controller = Controller
    def __init__(self, parent=None, height=None):
        super().__init__(parent)
        self.height_value = height  # Начальная высота

        self.num_points = 11  # Количество точек

        # Создаем слайдер внутри этого виджета
        self.slider = QtWidgets.QSlider(self)
        self.slider.setOrientation(QtCore.Qt.Vertical)  # Вертикальный слайдер
        self.slider.setRange(0, int(height) * 1000)  # Диапазон слайдера
        self.slider.setValue(0)  # Начальное значение слайдера
        self.slider.setGeometry(QtCore.QRect(1, 40, 40, 451))  # Размещение слайдера внутри виджета

    def updateSlider(self, new):
        """ Обновляем отображение точек в зависимости от значения слайдера """
        self.slider.setValue(new)

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Настройки для рисования точек
        point_radius = 5
        point_color = QtCore.Qt.black
        painter.setBrush(QtGui.QBrush(point_color))

        # Рассчитываем координаты для точек
        slider_height = self.slider.height()  # Получаем высоту слайдера

        # Распределяем точки от 0 до 451 (верхний предел слайдера)
        for i in range(self.num_points):
            # Вычисляем пропорциональное расположение каждой точки
            y_pos = i * (slider_height / (self.num_points - 1)) + 40  # От 0 до 451 на 10 точках
            # Рисуем точку
            painter.drawEllipse(self.slider.width() // 2 - point_radius, int(y_pos) - point_radius, point_radius * 2,
                                point_radius * 2)

            text = f"{round(self.height_value / 10 * (10 - i), 2)} м"
            # Упростим выражение с тернарным оператором

            text_rect = QtCore.QRect(self.slider.width() - 5, int(y_pos) - 10, 40, 20)  # Прямоугольник для текста
            painter.setPen(QtCore.Qt.black)  # Цвет текста (черный)
            painter.drawText(text_rect, QtCore.Qt.AlignLeft, text)  # Рисуем текст

        painter.end()


class Ui_MaterialsChoice(object):
    def setupController(self, Controller):
        self.Controller = Controller

    def setupUi(self, MaterialsChoice):
        self.window =MaterialsChoice
        MaterialsChoice.setObjectName("MaterialsChoice")
        MaterialsChoice.resize(1162, 706)

        self.globalGroupBox = QtWidgets.QGroupBox(MaterialsChoice)
        self.globalGroupBox.setGeometry(QtCore.QRect(110, 80, 891, 581))

        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.globalGroupBox.sizePolicy().hasHeightForWidth())
        self.globalGroupBox.setSizePolicy(sizePolicy)

        self.globalGroupBox.setStyleSheet("#globalGroupBox {\n"
                                          "    border: 2px solid black; /* Толщина и цвет рамки */\n"
                                          "    border-radius: 100px;    /* Радиус закругления */\n"
                                          "    background-color: white; /* Цвет фона (опционально) */\n"
                                          "}\n")
        self.globalGroupBox.setTitle("")
        self.globalGroupBox.setAlignment(QtCore.Qt.AlignCenter)
        self.globalGroupBox.setObjectName("globalGroupBox")

        # Второй GroupBox внутри глобального GroupBox
        self.globalGroupBox_2 = QtWidgets.QGroupBox(self.globalGroupBox)
        self.globalGroupBox_2.setGeometry(QtCore.QRect(510, 40, 311, 461))

        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.globalGroupBox_2.sizePolicy().hasHeightForWidth())
        self.globalGroupBox_2.setSizePolicy(sizePolicy)

        self.globalGroupBox_2.setStyleSheet("#globalGroupBox_2 {\n"
                                            "    border: 2px solid black; /* Толщина и цвет рамки */\n"
                                            "    border-radius: 70px;    /* Радиус закругления */\n"
                                            "    background-color: white; /* Цвет фона (опционально) */\n"
                                            "}\n")
        self.globalGroupBox_2.setTitle("")
        self.globalGroupBox_2.setAlignment(QtCore.Qt.AlignCenter)
        self.globalGroupBox_2.setObjectName("globalGroupBox_2")

        # ScrollArea для сырья
        self.scrollArea = QtWidgets.QScrollArea(self.globalGroupBox_2)
        self.scrollArea.setGeometry(QtCore.QRect(10, 60, 291, 331))  # Настроим размеры области прокрутки
        self.scrollArea.setWidgetResizable(True)  # Чтобы содержимое скроллилось

        # Контейнер для элементов в scrollArea
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)

        # Лейаут для размещения кнопок
        self.scrollLayout = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.scrollLayout.setObjectName("scrollLayout")

        syrio_list = [
            Syrio(name="Сырьё 1", percentage=20.0, density=1.2, color=Qt.red),
            Syrio(name="Сырьё 2", percentage=30.0, density=1.5, color=Qt.green),
            Syrio(name="Сырьё 3", percentage=40.0, density=1.7, color=Qt.blue),
            Syrio(name="Сырьё 4", percentage=10.0, density=1.8, color=Qt.yellow),
            Syrio(name="Сырьё 5", percentage=25.0, density=1.3, color=Qt.magenta),
            Syrio(name="Сырьё 6", percentage=35.0, density=1.6, color=Qt.cyan),
            Syrio(name="Сырьё 7", percentage=45.0, density=1.9, color=Qt.gray),
            Syrio(name="Сырьё 8", percentage=15.0, density=2.0, color=Qt.darkYellow),
            Syrio(name="Сырьё 9", percentage=50.0, density=1.1, color=Qt.darkGreen),
            Syrio(name="Сырьё 10", percentage=20.0, density=1.4, color=Qt.darkBlue)
        ]

        # Добавляем несколько кнопок (items) в scrollArea
        for i, syrio in enumerate(syrio_list):
            button = DragButton(syrio)
            button.setObjectName(f"button_{i}")
            self.scrollLayout.addWidget(button)

        # Линия внутри GroupBox 2
        self.line = QtWidgets.QFrame(self.globalGroupBox_2)
        self.line.setGeometry(QtCore.QRect(0, 390, 305, 20))
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")

        # Вторая линия внутри GroupBox 2
        self.line_3 = QtWidgets.QFrame(self.globalGroupBox_2)
        self.line_3.setGeometry(QtCore.QRect(0, 50, 305, 20))
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")

        # Кнопка добавления внутри GroupBox 2
        self.pushButton_2 = QtWidgets.QPushButton(self.globalGroupBox_2)
        self.pushButton_2.setGeometry(QtCore.QRect(130, 400, 41, 41))
        font = QtGui.QFont()
        font.setPointSize(22)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")

        # Метка внутри GroupBox 2
        self.label_5 = QtWidgets.QLabel(self.globalGroupBox_2)
        self.label_5.setGeometry(QtCore.QRect(110, 10, 101, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(True)
        font.setWeight(75)
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")

        # Третий GroupBox внутри глобального GroupBox
        self.dragDropGroupBox = DragDropGroupBox(self.globalGroupBox, reactor_height=self.Controller.height)
        self.dragDropGroupBox.setGeometry(QtCore.QRect(120, 40, 311, 451))

        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dragDropGroupBox.sizePolicy().hasHeightForWidth())
        self.dragDropGroupBox.setSizePolicy(sizePolicy)

        self.dragDropGroupBox.setStyleSheet("#globalGroupBox_3 {\n"
                                            "    border: 2px solid black; /* Толщина и цвет рамки */\n"
                                            "    border-radius: 0px;    /* Радиус закругления */\n"
                                            "    background-color: white; /* Цвет фона (опционально) */\n"
                                            "}\n")
        self.dragDropGroupBox.setTitle("")
        self.dragDropGroupBox.setAlignment(QtCore.Qt.AlignCenter)
        self.dragDropGroupBox.setObjectName("globalGroupBox_3")
        self.dragDropGroupBox.setAcceptDrops(True)

        # Реактор GroupBox
        self.rt = QtWidgets.QGroupBox(self.globalGroupBox)
        self.rt.setGeometry(QtCore.QRect(120, 500, 311, 61))
        self.rt.setStyleSheet("#rt {\n"
                              "    border: 2px solid black;\n"
                              "    border-radius: 70px;\n"
                              "    background-color: white;\n"
                              "}\n")
        self.rt.setObjectName("rt")

        # Горизонтальный Layout для реактора
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.rt)
        self.horizontalLayout.setObjectName("horizontalLayout")

        # Метка для реактора
        self.label_2 = QtWidgets.QLabel(self.rt)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)

        # Double Spin Box для вводимой величины
        self.doubleSpinBox = QtWidgets.QDoubleSpinBox(self.rt)
        self.doubleSpinBox.setObjectName("doubleSpinBox")
        self.horizontalLayout.addWidget(self.doubleSpinBox)

        # Кнопка добавления для реактора
        self.pushButton_3 = QtWidgets.QPushButton(self.rt)
        font = QtGui.QFont()
        font.setPointSize(22)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setObjectName("pushButton_3")
        self.horizontalLayout.addWidget(self.pushButton_3)

        # Метка для группы реактора
        self.label_6 = QtWidgets.QLabel(self.globalGroupBox)
        self.label_6.setGeometry(QtCore.QRect(120, 0, 131, 41))
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.label_6.setFont(font)
        self.label_6.setObjectName("label_6")

        # Кнопка для запуска модели
        self.startModel = QtWidgets.QPushButton(self.globalGroupBox)
        self.startModel.setGeometry(QtCore.QRect(560, 520, 201, 47))

        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.startModel.sizePolicy().hasHeightForWidth())
        self.startModel.setSizePolicy(sizePolicy)

        self.startModel.setStyleSheet("#startModel {\n"
                                      "    background-color: blue;    /* Синий фон кнопки */\n"
                                      "    color: white;              /* Белый цвет текста */\n"
                                      "    font-size: 16px;           /* Увеличенный размер текста */\n"
                                      "    border-radius: 10px;       /* Закругление краев */\n"
                                      "    padding: 10px 15px;        /* Отступы */\n"
                                      "    margin-top: 8px;\n"
                                      "}\n"
                                      "\n"
                                      "#startModel::indicator {\n"
                                      "    width: 25px;               /* Увеличенный размер кружка */\n"
                                      "    height: 25px;              /* Увеличенный размер кружка */\n"
                                      "    border: 3px solid white;   /* Белая обводка кружка */\n"
                                      "    background-color: blue;    /* Синий цвет кружка */\n"
                                      "    border-radius: 12px;       /* Закругление кружка */\n"
                                      "}\n"
                                      "\n"
                                      "#startModel::indicator::checked {\n"
                                      "    background-color: white;   /* Белый фон для выбранного состояния */\n"
                                      "    border: 3px solid blue;    /* Синяя обводка выбранного кружка */\n"
                                      "}\n")
        self.startModel.setObjectName("startModel")
        self.startModel.clicked.connect(self.continue_)

        self.pointsWidget = PointsScrollerWidget(self.globalGroupBox, self.Controller.height)
        self.pointsWidget.setGeometry(QtCore.QRect(30, 0, 90, 520))  # Размещение рядом с реактором
        self.pointsWidget.setObjectName("pointsWidget")

        # # Подключаем сигнал изменения значения doubleSpinBox
        self.doubleSpinBox.valueChanged.connect(self.updateSliderFromSpinBox)
        # # Подключаем сигнал изменения значения слайдера
        self.pointsWidget.slider.valueChanged.connect(self.updateSpinBoxFromSlider)

        self.pushButton_3.clicked.connect(self.addLayerToReactor)

        self.retranslateUi(MaterialsChoice)
        QtCore.QMetaObject.connectSlotsByName(MaterialsChoice)

    def continue_(self):
        self.Controller.items_and_layers = self.dragDropGroupBox.items_and_layers
        print(self.Controller.items_and_layers)
        self.window.close()

    def addLayerToReactor(self):
        """Передает значение высоты слоя в DragDropGroupBox и обновляет."""
        height = self.doubleSpinBox.value()
        self.dragDropGroupBox.addLayer(height)

    def updateSliderFromSpinBox(self, value):
        """Обновляет положение слайдера на основе значения в doubleSpinBox."""
        slider_value = int(value * 1000)
        self.pointsWidget.slider.setValue(slider_value)

    def updateSpinBoxFromSlider(self, value):
        """Обновляет значение doubleSpinBox на основе позиции слайдера."""
        # Перевод значения слайдера (0-1000) в метры
        height_in_meters = value / 1000.0
        self.doubleSpinBox.setValue(height_in_meters)

    def retranslateUi(self, MaterialsChoice):
        _translate = QtCore.QCoreApplication.translate
        MaterialsChoice.setWindowTitle(_translate("MaterialsChoice", "MaterialsChoice"))
        self.pushButton_2.setText(_translate("MaterialsChoice", "+"))
        self.label_5.setText(_translate("MaterialsChoice", "Сырьё"))
        self.label_2.setText(_translate("MaterialsChoice", "  Новый слой(м):"))
        self.pushButton_3.setText(_translate("MaterialsChoice", "+"))
        self.label_6.setText(_translate("MaterialsChoice", "Реактор:"))
        self.startModel.setText(_translate("MaterialsChoice", "Продолжить"))


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MaterialsChoice()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
